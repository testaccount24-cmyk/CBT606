         COPY     #GLOBAL
$XPRINTF CSECT
* =====================================================================
* Open SYSPRINT
*
* static void $$PRTO( void )
* =====================================================================
$$PRTO   #PROLOG  ENTRY=YES,CSECT=NO        Entry
         LA       R9,$$PDCB                 Cache DCB ptr
         USING    IHADCB,R9                 Map DCB
         TM       DCBOFLGS,DCBOFOPN         File already open?
         BO       &L.2                      Yes, don't re-open
         OPEN     ($$PDCB,OUTPUT)           Open SYSPRINT
         TM       DCBOFLGS,DCBOFOPN         Did it open?
         BNO      &L.BAD                    No, go complain
         LH       R3,DCBLRECL               Get record length
         ST       R3,$$PML                  $$pml = record length
         XR       R1,R1                     Clear initial length
         TM       DCBRECFM,DCBRECV          Variable records?
         BNO      &L.1                      No, branch
         L        R1,=F'4'                  Size of RDW
&L.1     ST       R1,$$PIL                  Save initial record length
         ST       R1,$$PCL                  Make it the current length
&L.2     #EPILOG                            Exit
         DROP     R9                        Unmap DCB
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
&L.BAD   ABEND    1221,DUMP                 SYSPRINT didn't open
* =====================================================================
* Close SYSPRINT
*
* static void $$PRTC( void )
* =====================================================================
$$PRTC   #PROLOG  ENTRY=YES,CSECT=NO        Entry
         LA       R9,$$PDCB                 Cache DCB ptr
         USING    IHADCB,R9                 Map DCB
         TM       DCBOFLGS,DCBOFOPN         Is file open?
         BNO      &L.1                      No, don't try to close it
         CLOSE    $$PDCB                    Close the file
         FREEPOOL $$PDCB                    Free buffers
&L.1     XC       $$PRP,$$PRP               Reset record pointer
         XC       $$PML,$$PML               Reset max length
         XC       $$PIL,$$PIL               Reset initial length
         XC       $$PCL,$$PCL               Reset current length
         #EPILOG                            Exit
         DROP     R9                        Unmap DCB
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
* =====================================================================
* Put character to SYSPRINT
*
* static void $$PUTCH(int ch, void *arg)
* =====================================================================
$$PUTCH  #PROLOG  ENTRY=NO,CSECT=NO
         L        R2,0(R1)                  Cache ch
         N        R2,=X'000000FF'           ch &= 0xff
         LA       R9,$$PDCB                 Cache DCB ptr
         USING    IHADCB,R9                 Map DCB
         TM       DCBOFLGS,DCBOFOPN         SYSPRINT open?
         BO       &L.1                      Yes, branch
         #CALL    $$PRTO                    Go open it
*
*
*
&L.1     L        R4,$$PCL                  curlen = $$pcl
         ICM      R3,B'1111',$$PRP          (currp = $$prp) == 0?
         BNZ      &L.30                     No, go store the character
*
* Need to get a new record buffer
*
         PUT      $$PDCB                    Get a record
         ST       R1,$$PRP                  $$prp = t1
         TM       DCBRECFM,DCBRECV          RECFM = V?
         BNO      &L.5                      No, skip rdw init
         XC       0(4,R1),0(R1)             Clear RDW
&L.5     LR       R3,R1                     currp = t1
         L        R4,$$PIL                  curlen = $$pil
         ST       R4,$$PCL                  $$pcl = curlen
         CL       R2,=X'00000015'           ch = x'15'?
         BNE      &L.31                     No, normal processing
*
* Output a blank record.  RECFM=V must have a least 1 valid byte
*
         TM       DCBRECFM,DCBRECV          RECFM = V?
         BNO      &L.12                     No, go do fixed
         CL       R4,$$PIL                  curlen = $$pil?
         BNE      &L.11                     No, not a null record
         LA       R2,C' '                   ch = ' '
         STC      R2,0(R4,R3)               currpÝ curlen ¨ = ch
         A        R4,=F'1'                  curlen++
         B        &L.11                     Go finalize record
*
* Record full (or blank) so finalize it
*
&L.10    TM       DCBRECFM,DCBRECV          RECFM = V?
         BNO      &L.12                     No, go do fixed
&l.11    STH      R4,0(R3)                  Store len in RDW
         B        &L.13                     Branch
&L.12    L        R6,$$PML                  Get maximum record length
         SLR      R6,R4                     Calc remaining length
         LA       R5,0(R3,R4)               Calc ptr to remaining bytes
         #MEMSET  (R5),C' ',(R6)            Blank remaining bytes
&L.13    XR       R3,R3                     Clear record pointer
         ST       R3,$$PRP                  Store it
         B        &L.99                     Done
*
* Already have a record pointer
*
&L.30    CL       R2,=X'00000015'           ch = x'15'?
         BE       &L.10                     Yes, record complete
&L.31    STC      R2,0(R4,R3)               currpÝ curlen ¨ = ch
         A        R4,=F'1'                  curlen++
         CL       R4,$$PML                  curlen == $$pml?
         BE       &L.10                     Yes, record complete
         ST       R4,$$PCL                  $$pcl = curlen
*
*
*
&L.99    #EPILOG                            Exit
         DROP     R9                        Unmap DCB
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
*
* Static (volatile) data
*
$$PRP    DC       A(0)                      Current record
$$PCL    DC       F'0'                      Current record length
$$PIL    DC       F'0'                      Initial record length
$$PML    DC       F'0'                      Maximum record length
$$PDCB   DCB      DSORG=PS,MACRF=PL,DDNAME=SYSPRINT
*
* int printf(const char *fmt,...)
*
printf   #PROLOG  ENTRY=YES,CSECT=NO        Entry
         L        R2,0(R1)                  Get fmt parm
         L        R3,=A($$PUTCH)            Get func parm
         XR       R4,R4                     No buf parm
         LA       R5,4(R1)                  Calc ap parm
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R2,R5)             Go do the real work
         #EPILOG                            Exit
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
*
* void vprintf(const char *fmt, va_list ap)
*
vprintf  #PROLOG  ENTRY=YES,CSECT=NO        Entry
         L        R2,0(R1)                  Get fmt parm
         L        R3,=A($$PUTCH)            Get func parm
         XR       R4,R4                     No buf parm
         L        R5,4(R1)                  Get ap parm
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R2,R5)             Go do the real work
         #EPILOG                            Exit
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
*
* int sprintf(char *buf, const char *cfmt,...)
*
sprintf  #PROLOG  ENTRY=YES,CSECT=NO        Entry
         L        R2,4(R1)                  Get fmt parm
         XR       R3,R3                     No func parm
         L        R4,0(R1)                  Get buf parm
         LA       R5,8(R1)                  Calc ap parm
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R2,R5)             Go do the real work
         STC      R3,0(R15,R4)              bufÝ rc ¨ = '\0'
         #EPILOG                            Exit
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
*
* int vsprintf(char *buf, const char *cfmt, va_list ap)
*
vsprintf #PROLOG  ENTRY=YES,CSECT=NO        Entry
         L        R2,4(R1)                  Get fmt parm
         XR       R3,R3                     No func parm
         L        R4,0(R1)                  Get buf parm
         L        R5,8(R1)                  Get ap parm
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R2,R5)             Go do the real work
         STC      R3,0(R15,R4)              bufÝ rc ¨ = '\0'
         #EPILOG                            Exit
         DROP     R12                       Unbase
         #FRAME   START                     Start of frame
         #FRAME   END                       End of frame
* =====================================================================
* Internal snprintf argument structure
* =====================================================================
$$SNPRTA EQU      12,8,C'X'                 Internal snprintf arg
$$SNPSTR EQU      0,4,C'A'                  Ptr to output buffer
$$SNPLEN EQU      4,4,C'F'                  output buffer len - 1
$$SNPIDX EQU      8,4,C'F'                  output buffer index
*
* static void isnprint(int ch, void *arg)
*
$$SNPRTF #PROLOG  ENTRY=NO,CSECT=NO,SAVE=NO,FRAME=NO,BASER=R15
         LM       R0,R1,0(R1)               Load parms
         L        R15,$$SNPIDX(R1)          i = current index
         LA       R15,1(R15)                i++
         CL       R15,$$SNPLEN(R1)          Room for this character?
         BNL      &L.99                     No, don't store it
         ST       R15,$$SNPIDX(R1)          current index = i
&L.99    #EPILOG                            Exit
         DROP     R15                       Unbase
*
* int snprintf(char *str, size_t size, const char *format,...)
*
snprintf #PROLOG  ENTRY=YES,CSECT=NO        Entry
         LM       R2,R4,0(R1)               Get parms
         XR       R15,R15                   ret = 0
         BCTR     R3,0                      Reserve room for null
         LTR      R3,R3                     len <= 0?
         BL       &L.2                      Less, nothing to do
         BE       &L.1                      Equal, store null and exit
         XC       &L.SA,&L.SA               sa = {0,0,0}
         STM      R2,R3,&L.SA               Save ptr and len
         L        R5,=A($$SNPRTF)           Get func ptr
         LA       R6,&L.SA                  Get sa ptr
         LA       R7,12(R1)                 Calc ap ptr
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R4,R7)             Go do the real work
         LM       R2,R4,&L.SA               Get ptr, len, and idx
         LR       R15,R4                    ret = idx
&L.1     XR       R1,R1                     Clear reg
         STC      R1,0(R15,R2)              ptrÝ idx ¨ = '\0'
&L.2     #EPILOG                            Exit
         #FRAME   START                     Start of frame
&L.SA    DS       0F,XL($$SNPRTA)           sa
         #FRAME   END                       End of frame
*
* int vsnprintf(char *str, size_t size, const char *format, va_list ap)
*
vsnprint #PROLOG  ENTRY=YES,CSECT=NO        Entry
         LM       R2,R4,0(R1)               Get parms
         XR       R15,R15                   ret = 0
         BCTR     R3,0                      Reserve room for null
         LTR      R3,R3                     len <= 0?
         BL       &L.2                      Less, nothing to do
         BE       &L.1                      Equal, store null and exit
         XC       &L.SA,&L.SA               sa = {0,0,0}
         STM      R2,R3,&L.SA               Save ptr and len
         L        R5,=A($$SNPRTF)           Get func ptr
         LA       R6,&L.SA                  Get sa ptr
         L        R7,12(R1)                 Get ap ptr
         L        R15,=A($$IVPRTF)          Get ivprintf ptr
         #CALL    (R15),(R4,R7)             Go do the real work
         LM       R2,R4,&L.SA               Get ptr, len, and idx
         LR       R15,R4                    ret = idx
&L.1     XR       R1,R1                     Clear reg
         STC      R1,0(R15,R2)              ptrÝ idx ¨ = '\0'
&L.2     #EPILOG                            Exit
         DROP     R12                       Unbase
         #FRAME   START                     Start of frame
&L.SA    DS       0F,XL($$SNPRTA)           sa
         #FRAME   END                       End of frame
*
* static int
* ivprintf(char const * fmt,
*                  void (*func) (int, void *),
*                  void *arg,
*                  va_list ap)
*
RRET     EQU      R9
RFMT     EQU      R8
RSIZE    EQU      R7
RAP      EQU      R6
RCP      EQU      R5
*
$$IVPRTF #PROLOG  ENTRY=NO,CSECT=NO,BASER=R11
         LA       R12,4095(R11)             Bump base 2 by 4095
         LA       R12,1(R12)                And by 1 more
         USING    $$IVPRTF+4096,R12         Establish base 2
         LM       R2,R5,0(R1)               Load parameters
         ST       R2,&L.FMT                 Save fmt parm
         ST       R3,&L.FUNC                Save func parm
         ST       R4,&L.ARG                 Save arg parm
         ST       R5,&L.AP                  Save ap parm
*
         L        RFMT,&L.FMT               Cache fmt ptr
         L        RAP,&L.AP                 Cache ap ptr
*
         XR       RRET,RRET                 Preset return value
*
&L.10    DS       0H                        for( ;; )
*
         LR       RCP,RFMT                  cp = fmt
&L.10A   CLI      0(RFMT),X'00'             *fmt == '\0'?
         BE       &L.10B                    Yes, break
         CLI      0(RFMT),C'%'              *fmt = '%'?
         BE       &L.10B                    Yes, break
         LA       RFMT,1(RFMT)              fmt++
         B        &L.10A                    Continue
*
&L.10B   LR       R3,RFMT                   t3 = fmt
         SLR      R3,RCP                    t3 -= cp
         LTR      R3,R3                     t3 == 0?
         BZ       &L.10C                    Yes, nothing to print
         AR       RRET,R3                   ret += t3
         BL       &L.80                     ret < 0 ? goto error
         LR       R2,RCP                    t2 = cp
         BAL      R4,&L.PRT                 Go print the string
&L.10C   CLI      0(RFMT),X'00'             *fmt == '\0'?
         BE       &L.90                     Yes, we're done
         LA       RFMT,1(RFMT)              fmt++
         XR       R1,R1                     t1 = 0
         ST       R1,&L.DPREC               dprec = t1
         ST       R1,&L.WDTH                width = t1
         STC      R1,&L.SIGN                size = t1
         MVC      &L.PREC,=F'-1'            prec = -1
         MVI      &L.FLG,FLONG              flags = FLONG
*
&L.RF    DS       0H
         XR       R1,R1                     t1 = '\0'
         IC       R1,0(RFMT)                t1 = *fmt
         LA       RFMT,1(RFMT)              fmt++
         XR       R2,R2                     t2 = 0
         IC       R2,SWTAB(R1)              t2 = swtabÝ t1 ¨
         B        &L.JMP(R2)                switch
&L.JMP   B        &L.C99                    default
         B        &L.C1                     case ' '
         B        &L.C2                     case '+'
         B        &L.C3                     case '#'
         B        &L.C4                     case '-'
         B        &L.C5                     case '0'
         B        &L.C6                     case '*'
         B        &L.C7                     case '1' - '9'
         B        &L.C8                     case '.'
         B        &L.C9                     case 'h'
         B        &L.C10                    case 'l'
         B        &L.C11                    case 'c'
         B        &L.C12                    case 'd', 'i'
         B        &L.C13                    case 'n'
         B        &L.C14                    case 'o'
         B        &L.C15                    case 'p'
         B        &L.C16                    case 's'
         B        &L.C17                    case 'u'
         B        &L.C18                    case 'X'
         B        &L.C19                    case 'x'
         B        &L.C20                    case '\''
* ---------------------------------------------------------------------
* Flags
* ---------------------------------------------------------------------
*
* *** CASE '\''
*
&L.C20   DS       0H                        CASE '\'':
         OI       &L.FLG,FTHOU              flag |= FTHOU
         B        &L.RF                     Goto rflag
*
* *** CASE ' '
*
&L.C1    DS       0H                        CASE '.':
         CLI      &L.SIGN,X'00'             Already have sign?
         BNE      &L.RF                     Yes, ignore it
         MVI      &L.SIGN,C' '              sign = ' '
         B        &L.RF                     Goto rflag
*
* *** CASE '+'
*
&L.C2    DS       0H                        CASE '+':
         MVI      &L.SIGN,C'+'              sign = '+'
         B        &L.RF                     Goto rflag
*
* *** CASE '#'
*
&L.C3    DS       0H                        CASE '#':
         OI       &L.FLG,FALT               flag |= FALT
         B        &L.RF                     Goto rflag
*
* *** CASE '-'
*
&L.C4    DS       0H                        CASE '-':
         OI       &L.FLG,FLJUST             flags |= FLJUST
         NI       &L.FLG,255-FZPAD          flags &= (~FZPAD)
         B        &L.RF                     Goto rflag
*
* *** CASE '0'
*
&L.C5    DS       0H                        CASE '0':
         OI       &L.FLG,FZPAD              flags |= FZPAD
         NI       &L.FLG,255-FLJUST         flags &= (~FLJUST)
         B        &L.RF                     Goto rflag
* ---------------------------------------------------------------------
* Width
* ---------------------------------------------------------------------
*
* *** CASE '*'
*
&L.C6    DS       0H                        CASE '*':
         XR       R1,R1                     t1 = 0
         XR       R2,R2                     n = 0
         LR       RCP,RFMT                  cp = fmt
&L.C6A   CLI      0(RCP),C'0'               *cp < 0?
         BL       &L.C6B                    Yes, exit loop
         CLI      0(RCP),C'9'               *cp > 9?
         BH       &L.C6B                    Yes, exit loop
         IC       R1,0(RCP)                 t1 = *cp
         SH       R1,=H'240'                t1 = t1 - c'0'
         LR       R0,R2                     t0 = n
         SLL      R2,2                      n = n * 4
         AR       R2,R0                     n = n + t0
         SLL      R2,1                      n = n * 2
         AR       R2,R1                     n = n + t1
         LA       RCP,1(RCP)                cp = cp + 1
         B        &L.C6A                    Loop
&L.C6B   CLI      0(RCP),C'$'               *cp = '$'?
         BNE      &L.C6C                    No, just get next arg
         SLL      R2,2                      n = n * 4
         L        R1,&L.AP                  t1 = &apÝ 0 ¨
         L        R1,0(R2,R1)               n = t1Ý n ¨
         LA       RFMT,1(RCP)               fmt = ++cp
         B        &L.C6D                    Branch
&L.C6C   L        R1,0(RAP)                 val = *ap
         LA       RAP,4(RAP)                ap++
&L.C6D   ST       R1,&L.WDTH                width = t1
         LTR      R1,R1                     t1 >= 0?
         BNL      &L.RF                     Goto rflag
         LCR      R1,R1                     t1 = -t1
         ST       R1,&L.WDTH                width = t1
         OI       &L.FLG,FLJUST             flags |= FLJUST
         NI       &L.FLG,255-FZPAD          flags &= (~FZPAD)
         B        &L.RF                     Goto rflag
*
* *** CASE '1' - '9'
*
&L.C7    DS       0H                        CASE '1' - '9':
         XR       R2,R2                     n = 0
&L.C7A   SH       R1,=H'240'                t1 = t1 - c'0'
         LR       R0,R2                     t0 = n
         SLL      R2,2                      n = n * 4
         AR       R2,R0                     n = n + t0
         SLL      R2,1                      n = n * 2
         AR       R2,R1                     n = n + t1
         CLI      0(RFMT),C'0'              *fmt < 0?
         BL       &L.C7B                    Yes, exit loop
         CLI      0(RFMT),C'9'              *fmt > 9?
         BH       &L.C7B                    Yes, exit loop
         IC       R1,0(RFMT)                ch = *fmt
         LA       RFMT,1(RFMT)              fmt = fmt + 1
         B        &L.C7A                    Loop
&L.C7B   CLI      0(RFMT),C'$'              *fmt = '$'?
         BNE      &L.C7C                    No, just get next arg
         SLL      R2,2                      n = n * 4
         L        RAP,&L.AP                 ap = &apÝ 0 ¨
         LA       RAP,0(R2,RAP)             ap = &apÝ n ¨
         LA       RFMT,1(RFMT)              fmt++
         B        &L.RF                     Goto rflag
&L.C7C   ST       R2,&L.WDTH                width = n
*        OI       &L.FLG,FLJUST             flags |= FLJUST
         B        &L.RF                     Goto rflag
* ---------------------------------------------------------------------
* Precision
* ---------------------------------------------------------------------
*
* *** CASE '.'
*
&L.C8    DS       0H                        CASE '.':
         XR       R1,R1                     t1 = 0
         XR       R2,R2                     n = 0
         LR       RCP,RFMT                  cp = fmt
         CLI      0(RCP),C'*'               *cp == '*'?
         BNE      &L.C8A                    Nope, branch
         LA       RCP,1(RCP)                cp++
&L.C8A   CLI      0(RCP),C'0'               *cp < 0?
         BL       &L.C8B                    Yes, exit loop
         CLI      0(RCP),C'9'               *cp > 9?
         BH       &L.C8B                    Yes, exit loop
         IC       R1,0(RCP)                 t1 = *cp
         SH       R1,=H'240'                t1 = t1 - c'0'
         LR       R0,R2                     t0 = n
         SLL      R2,2                      n = n * 4
         AR       R2,R0                     n = n + t0
         SLL      R2,1                      n = n * 2
         AR       R2,R1                     n = n + t1
         LA       RCP,1(RCP)                cp++
         B        &L.C8A                    Loop
&L.C8B   CLI      0(RFMT),C'*'              *fmt = '*'?
         BNE      &L.C8D                    No, just plain number
         CLI      0(RCP),C'$'               *cp = '$'?
         BNE      &L.C8C                    No, just get next arg
         SLL      R2,2                      n = n * 4
         L        R1,&L.AP                  t1 = &apÝ 0 ¨
         L        R2,0(R2,R1)               n = t1Ý n ¨
*        LA       RFMT,1(RCP)               fmt = ++cp
         LA       RFMT,1(RFMT)              fmt++
         B        &L.C8D                    Branch
&L.C8C   L        R2,0(RAP)                 n = *ap
         LA       RAP,4(RAP)                ap++
&L.C8D   LTR      R2,R2                     n >= 0?
         BNL      &L.C8E                    Yes, use it
         L        R2,=F'-1'                 n = -1
&L.C8E   ST       R2,&L.PREC                prec = n
         LR       RFMT,RCP                  fmt = cp
         B        &L.RF                     Goto rflag
* ---------------------------------------------------------------------
* Sizes
* ---------------------------------------------------------------------
*
* *** CASE 'h'
*
&L.C9    DS       0H                        CASE 'h':
         NI       &L.FLG,255-FLONG          flags &= (~FLONG)
         B        &L.RF                     Goto rflag
*
* *** CASE 'l'
*
&L.C10   DS       0H                        CASE 'l':
         OI       &L.FLG,FLONG              flags |= FLONG
         B        &L.RF                     Goto rflag
* ---------------------------------------------------------------------
* Types
* ---------------------------------------------------------------------
*
* *** CASE 'c'
*
&L.C11   DS       0H                        CASE 'c'
         LA       RSIZE,1                   size = 1
         LA       RCP,&L.BUF                cp = &bufÝ 0 ¨
         STC      R1,0(RCP)                 *cp = t1
         B        &L.50                     Break
*
* *** CASE 'd', 'i'
*
&L.C12   DS       0H                        CASE 'd', 'i'
         L        R2,0(RAP)                 n = *ap
         TM       &L.FLG,FLONG              flags & FLONG?
         BO       &L.C12A                   Yes, branch
         SLL      R2,16                     n <<= 16
         SRA      R2,16                     n >>= 16 (sign extended)
&L.C12A  LA       RAP,4(RAP)                ap++
         LTR      R2,R2                     n < 0?
         BNL      &L.B10                    No, go process number
         LCR      R2,R2                     n = -n
         MVI      &L.SIGN,C'-'              sign = '-'
         B        &L.B10                    Go process number
*
* *** CASE 'n'
*
&L.C13   DS       0H                        CASE 'n'
         L        R1,0(RAP)                 t1 = *ap
         LA       RAP,4(RAP)                ap++
         TM       &L.FLG,FLONG              flags & FLONG?
         BO       &L.C13A                   Yes, go store long
         STH      RRET,0(R1)                *t1 = (short) ret
         B        &L.10                     Continue - no output
&L.C13A  ST       RRET,0(R1)                *t1 = ret
         B        &L.10                     Continue - no output
*
* *** CASE 'o'
*
&L.C14   DS       0H                        CASE 'o'
         B        &L.B8                     Goto base8
*
* *** CASE 'p'
*
&L.C15   DS       0H                        CASE 'p'
         OI       &L.FLG,FHEX               flags |= FHEX
         B        &L.B16                    Goto base16
*
* *** CASE 's'
*
&L.C16   DS       0H                        CASE 's'
         MVI      &L.SIGN,X'00'             sign = '\0'
         ICM      RCP,B'1111',0(RAP)        cp = *ap
         LA       RAP,4(RAP)                ap++
         BNZ      &L.C16A                   No, use it
         LA       RCP,NULLSTR               cp = "(null)"
&L.C16A  L        RSIZE,&L.PREC             size = prec
         #MEMCHR  (RCP),X'00',(RSIZE)       Look for null terminator
         LTR      R15,R15                   Find it?
         BZ       &L.50                     No, break
         SLR      R15,RCP                   Calc length
         LR       RSIZE,R15                 size = new length
         B        &L.50                     Break
*
* *** CASE 'u'
*
&L.C17   DS       0H                        CASE 'u'
         MVI      &L.SIGN,X'00'             sign = '\0'
         L        R2,0(RAP)                 n = *ap
         LA       RAP,4(RAP)                ap++
         B        &L.B10                    Goto base10
*
* *** CASE 'X'
*
&L.C18   DS       0H                        CASE 'x'
         OI       &L.FLG,FUHEX              flags |= FUHEX
         B        &L.B16                    Goto base16
*
* *** CASE 'x'
*
&L.C19   DS       0H                        CASE 'x'
         B        &L.B16                    Goto base16
*
* *** DEFAULT
*
&L.C99   DS       0H                        default
         LTR      R1,R1                     t1 = '\0'?
         BZ       &L.90                     Yep, goto done
         STC      R1,&L.BUF                 bufÝ 0 ¨ = t1
         LA       RCP,&L.BUF                cp = &bufÝ 0 ¨
         LA       RSIZE,1                   size = 1
         MVI      &L.SIGN,X'00'             sign = '\0'
         B        &L.50                     Break
*
*
*
&L.B8    DS       0H                        Base 8
         MVI      &L.SIGN,X'00'             sign = '\0'
         L        R2,0(RAP)                 n = *ap
         TM       &L.FLG,FLONG              flags & FLONG?
         BO       &L.B8A                    Yes, branch
         N        R2,=X'0000FFFF'           n &= 0xffff
&L.B8A   LA       RAP,4(RAP)                ap++
         LA       RCP,&L.BUF+11             cp = &bufÝ 11 ¨
         LR       R0,R2                     t0 = n
&L.B8B   BCTR     RCP,0                     --cp
         LR       R1,R0                     t1 = t0
         N        R1,=X'00000007'           t1 %= 8
         O        R1,=X'000000F0'           t1 |= 0xF0 (make number)
         STC      R1,0(RCP)                 *cp = t1
         SRL      R0,3                      t0 /= 8
         LTR      R0,R0                     t0 = 0?
         BNZ      &L.B8B                    No, continue
         TM       &L.FLG,FALT               flags & FALT?
         BNO      &L.B8C                    No, done
         CLI      0(RCP),C'0'               *cp = '0'?
         BE       &L.B8C                    Yes, not need another
         BCTR     RCP,0                     cp++
         MVI      0(RCP),C'0'               *cp = '0'
&L.B8C   LA       RSIZE,&L.BUF+11           size = &bufÝ 11 ¨
         SLR      RSIZE,RCP                 size -= cp
         B        &L.NBR                    Do common number processing
*
*
*
&L.B10   DS       0H                        Base 10
         CVD      R2,&L.DWRD                Convert to packed
         LTR      R2,R2                     n >= 0?
         BNM      &L.B10A                   Yes, branch
         AP       &L.DWRD,=P'4294967296'    Make it positive
&L.B10A  TM       &L.FLG,FTHOU              flags & FTHOU?
         BO       &L.B10C                   Yes, use commas
         LA       R1,&L.BUF+(L'&L.B10D-1)   Ptr to significant digit
         LA       RSIZE,1(R1)               Ptr to end of buffer
         MVC      &L.BUF(L'&L.B10D),&L.B10D Move edit pattern to buf
         EDMK     &L.BUF(L'&L.B10D),&L.DWRD+2 Make it readable
&L.B10B  SLR      RSIZE,R1                  Len of significant digits
         LR       RCP,R1                    cp = ptr to first digit
         LA       R1,&L.BUF+L'&L.B10D
         B        &L.NBR                    Do common number processing
&L.B10C  LA       R1,&L.BUF+(L'&L.B10E-1)   Ptr to significant digit
         LA       RSIZE,1(R1)               Ptr to end of buffer
         MVC      &L.BUF(L'&L.B10E),&L.B10E Move edit pattern to buf
         EDMK     &L.BUF(L'&L.B10E),&L.DWRD+2 Make it readable
         B        &L.B10B                   Go finish up
&L.B10D  DC       X'402020202020202020202120'       99999999999
&L.B10E  DC       X'4020206B2020206B2020206B202120' 99,999,999,999
*
*
*
&L.B16   DS       0H                        Base 16
         MVI      &L.SIGN,X'00'             sign = '\0'
         L        R2,0(RAP)                 n = *ap
         TM       &L.FLG,FLONG              flags & FLONG?
         BO       &L.B16A                   Yes, branch
         N        R2,=X'0000FFFF'           n &= 0xffff
&L.B16A  LA       RAP,4(RAP)                ap++
         LTR      R2,R2                     n = 0?
         BZ       &L.B16B                   Yes, skip alt format
         TM       &L.FLG,FALT               flags & FALT?
         BNO      &L.B16B                   No, goto nosign
         OI       &L.FLG,FHEX               flags |= FHEX
&L.B16B  LA       RCP,&L.BUF+8              cp = &bufÝ 8 ¨
         LR       R0,R2                     t0 = n
&L.B16C  BCTR     RCP,0                     --cp
         LR       R1,R0                     t1 = t0
         N        R1,=X'0000000F'           t1 %= 16
         IC       R1,&L.B16N(R1)            t1 = hexnumÝ t1 ¨
         STC      R1,0(RCP)                 *cp = t1
         SRL      R0,4                      t0 /= 16
         LTR      R0,R0                     t0 = 0?
         BNZ      &L.B16C                   No, continue
         LA       RSIZE,&L.BUF+8            size = &bufÝ 8 ¨
         SLR      RSIZE,RCP                 size -= cp
         TM       &L.FLG,FUHEX              flags & FUHEX?
         BNO      &L.B16D                   No, done
         OC       &L.BUF(8),=C'        '    Force to upper case
&L.B16D  B        &L.NBR                    Do common number processing
&L.B16N  DC       C'0123456789abcdef'       Hex character set
*
*
*
&L.NBR   DS       0H
         ICM      R1,B'1111',&L.PREC        t1 = prec
         ST       R1,&L.DPREC               dprec = t1
         BL       &L.N1                     prec < 0 ? branch
         NI       &L.FLG,255-FZPAD          flags &= ~FZPAD
&L.N1    LTR      R1,R1                     t1 = 0?
         BNZ      &L.N2                     No, keep size
         LTR      R2,R2                     n = 0?
         BNZ      &L.N2                     No, keep size
         XR       RSIZE,RSIZE               Don't output any characters
&L.N2    B        &L.50                     Break
*
* *** R2 = ch, R3 = size, R4 = retaddr
*
&L.PAD   DS       0H
         LTR      R3,R3
         BNHR     R4
         ST       R5,&L.DWRD
         ICM      R5,B'1111',&L.FUNC
         BZ       &L.PAD2
&L.PAD1  LR       R15,R5
         #CALL    (R15),(R2),&L.ARG
         BCT      R3,&L.PAD1
         L        R5,&L.DWRD
         BR       R4
&L.PAD2  L        R5,&L.ARG
         #MEMSET  (R5),(R2),(R3)
         LA       R15,0(R3,R15)
         ST       R15,&L.ARG
         L        R5,&L.DWRD
         BR       R4
*
* *** R2 = ptr, R3 = size, R4 = retaddr
*
&L.PRT   DS       0H
         LTR      R3,R3
         BNHR     R4
         ST       R5,&L.DWRD
         ICM      R5,B'1111',&L.FUNC
         BZ       &L.PRT2
&L.PRT1  IC       R1,0(R2)
         LA       R2,1(R2)
         LR       R15,R5
         #CALL    (R15),(R1)
         BCT      R3,&L.PRT1
         L        R5,&L.DWRD
         BR       R4
&L.PRT2  L        R5,&L.ARG
         #MEMCPY  (R5),(R2),(R3)
         LA       R15,0(R3,R15)
         ST       R15,&L.ARG
         L        R5,&L.DWRD
         BR       R4
*
* End of switch
*
&L.50    DS       0H                        End switch
*
* Calculate the actual size
*
         L        R1,&L.DPREC               t1 = dprec
         CR       R1,RSIZE                  t1 > size?
         BH       &L.51                     Yes, use dprec
         LR       R1,RSIZE                  t1 = size
&L.51    CLI      &L.SIGN,X'00'             sign == '\0'?
         BE       &L.52                     Yes, don't have a sign
         AL       R1,=F'1'                  t1++
         B        &L.53                     Have room for sign now
&L.52    TM       &L.FLG,FHEX               flags & FHEX?
         BNO      &L.53                     No, no hex prefix
         AL       R1,=F'2'                  t1 += 2
&L.53    ST       R1,&L.RSZ                 realsz = t1
*
         C        R1,&L.WDTH                realsz > width?
         BH       &L.54                     Yes, use realsz
         L        R1,&L.WDTH                t1 = width
&L.54    ST       R1,&L.PRSZ                prsize = t1
*
         AR       R1,RRET                   ( t1 += ret ) < 0?
         BL       &L.80                     Yes, too big
*
         L        R1,&L.WDTH                t1 = width
         S        R1,&L.RSZ                 t1 -= realsz
         ST       R1,&L.RPAD                rpad = t3
*
         TM       &L.FLG,FLJUST+FZPAD       flags & FLJUST|FZPAD?
         BM       &L.56                     Yes, skip blank padding
         L        R3,&L.RPAD                t3 = rpad
         LA       R2,C' '                   t2 = ' '
         BAL      R4,&L.PAD                 Go pad with blanks
*
&L.56    CLI      &L.SIGN,X'00'             sign == '\0'?
         BE       &L.57                     Yes, no sign
         LA       R3,1                      t3 = 1
         LA       R2,&L.SIGN                t2 = sign
         B        &L.59                     Go print it
&L.57    TM       &L.FLG,FHEX               flags & FHEX?
         BNO      &L.60                     No, no hex prefix
         LA       R3,2                      t3 = 2
         LA       R2,=C'0x'                 t2 = "0x"
         TM       &L.FLG,FUHEX              flags & FUHEX?
         BNO      &L.59                     No, leave it lower case
         LA       R2,=C'0X'                 t2 = "0X"
&L.59    BAL      R4,&L.PRT                 Go print the prefix
*
&L.60    IC       R1,&L.FLG                 t1 = flags
         N        R1,=A(FLJUST+FZPAD)       t1 &= FLJUST|FZPAD
         CL       R1,=A(FZPAD)              t1 == FZPAD?
         BNE      &L.61                     No, skip padding
         TM       &L.FLG,FLJUST             flags & FLJUST
         BO       &L.61                     Yes, skip padding
         L        R3,&L.RPAD                t3 = rpad
         LA       R2,C'0'                   t2 = '0'
         BAL      R4,&L.PAD                 Go pad with zeros
*
&L.61    L        R3,&L.DPREC               t3 = dprec
         SR       R3,RSIZE                  t3 -= size
         LA       R2,C'0'                   t2 = '0'
         BAL      R4,&L.PAD                 Go pad with zeros
*
         LR       R3,RSIZE                  t3 = size
         LR       R2,RCP                    t2 = cp
         BAL      R4,&L.PRT                 Go print string
*
         TM       &L.FLG,FLJUST             flags & FLJUST?
         BNO      &L.62                     No, not left justifying
         L        R3,&L.RPAD                t3 = rpad
         LA       R2,C' '                   t2 = ' '
         BAL      R4,&L.PAD                 Go pad with blanks
*
&L.62    AL       RRET,&L.PRSZ              ret += prsize
         B        &L.10                     Continue loop
*
*
*
&L.80    DS       0H                        Error
         L        RRET,=F'-1'               ret = -1
&L.90    DS       0H                        Done
         LR       R15,RRET                  Set return value
         #EPILOG                            Exit
* ***
         #FRAME   START                     Start of frame
*
&L.FMT   DS       A                         fmt
&L.FUNC  DS       A                         func
&L.ARG   DS       A                         arg
&L.AP    DS       A                         ap
*
&L.DWRD  DS       D                         dword
&L.RSZ   DS       F                         realsz
&L.PRSZ  DS       F                         prsize
&L.RPAD  DS       F                         rpad
&L.WDTH  DS       F                         width
&L.PREC  DS       F                         prec
&L.DPREC DS       F                         dprec
&L.SIGN  DS       C                         sign
&L.BUF   DS       CL68                      buf
&L.FLG   DS       C                         flags
FALT     EQU      X'01'                     ALT
FHEX     EQU      X'02'                     HEXPREFIX
FLJUST   EQU      X'04'                     LADJUST
FLONG    EQU      X'08'                     LONGINT
FZPAD    EQU      X'10'                     ZEROPAD
FUHEX    EQU      X'20'                     UPPERHEX
FTHOU    EQU      X'40'                     THOUSAND
         #FRAME   END                       End of frame
*
*
*
NULLSTR  #CSTR    '(null)'
*
* Generate switch table
*
         MACRO
         SW       &C,&I
         ORG      SWTAB+C&C
         DC       AL1(&I*4)
         ORG
         MEND
SWTAB    DC       256X'00'
         SW       ' ',1
         SW       '+',2
         SW       '#',3
         SW       '-',4
         SW       '0',5
         SW       '*',6
         SW       '1',7
         SW       '2',7
         SW       '3',7
         SW       '4',7
         SW       '5',7
         SW       '6',7
         SW       '7',7
         SW       '8',7
         SW       '9',7
         SW       '.',8
         SW       'h',9
         SW       'l',10
         SW       'c',11
         SW       'd',12
         SW       'i',12
         SW       'n',13
         SW       'o',14
         SW       'p',15
         SW       's',16
         SW       'u',17
         SW       'X',18
         SW       'x',19
         SW       '''',20
         ORG
*
         DCBD     DSORG=PS
*
         END
